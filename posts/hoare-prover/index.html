<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		 
			
  
    <meta name="twitter:card" content="summary"/>
    
      <meta name="twitter:image" content="https://gio54321.github.io/images/avatar.png" />
    
  
  
  <meta name="twitter:title" content="A simple Hoare triple prover"/>
  <meta name="twitter:description" content="How I created a simple automatic Hoare triple prover using python."/>
  
    <meta name="twitter:site" content="@g_dellimmagine"/>
  
  
  
  
    <meta name="twitter:creator" content="@Giorgio Dell&#39;Immagine"/>
  



		
		<meta name="author" content="Giorgio Dell&#39;Immagine">
		<meta name="description" content="Site Description">
		<meta name="generator" content="Hugo 0.68.3" />
		<title>A simple Hoare triple prover &middot; Giorgio Dell&#39;Immagine</title>
		<link rel="shortcut icon" href="https://gio54321.github.io/images/favicon.ico">
		<link rel="stylesheet" href="https://gio54321.github.io/css/style.css">
		<link rel="stylesheet" href="https://gio54321.github.io/css/prism.css">

		
		<link rel="stylesheet" href="https://gio54321.github.io/css/font-awesome.min.css">
		

		
		<link href="https://gio54321.github.io/index.xml" rel="alternate" type="application/rss+xml" title="Giorgio Dell&#39;Immagine" />
		

		
	</head>

    <body>
       <nav class="main-nav">
	
	
		<a href='https://gio54321.github.io/'> <span class="arrow">←</span>Home</a>
	
	<a href='https://gio54321.github.io/posts'>Archive</a>
	<a href='https://gio54321.github.io/about'>About</a>

	

	
	<a class="cta" href="https://gio54321.github.io/index.xml">Subscribe</a>
	
</nav>


        <section id="wrapper" class="post">
            <article>
                <header>
                    <h1>
                        A simple Hoare triple prover
                    </h1>
                    <h2 class="headline">
                    Feb 6, 2020 00:00
                    · 3238 words
                    · 16 minute read
                      <span class="tags">
                      
                      </span>
                    </h2>
                </header>
                
                <section id="post-body">
                    <h1 id="introduction-what-is-hoare-logic">Introduction: what is Hoare logic?</h1>

<h2 id="first-steps">First steps</h2>

<p>According to wikipedia:</p>

<blockquote>
<p>Hoare logic (also known as Floyd–Hoare logic or Hoare rules) is a formal system with a set of logical rules for reasoning rigorously about the correctness of computer programs.</p>
</blockquote>

<p>So this is a powerful system that let us reason <strong>formally</strong> about the correctness of our program. The basic structure of Hoare logic is the <strong>Hoare triple</strong>. A triple describes how some properties of the state are modified by the execution of a program. A triple has the form of</p>

<p><span  class="math">\[ \{P\}C\{Q\}\]</span></p>

<p>where <span  class="math">\(P\)</span> and <span  class="math">\(Q\)</span> are assertions and <span  class="math">\(C\)</span> is a program. <span  class="math">\(P\)</span> is called <strong>precondition</strong> and <span  class="math">\(Q\)</span> is called <strong>postcondition</strong>. A triple is said <strong>valid</strong> if, for each states that satisfies the precondition, the program <strong>terminates</strong> and the resulting state satisfies the postcondition.</p>

<p>I use a custom language for writing the program, that supports only empty statements, assignments, composition, if statemets and while statement. I'm sure you will have no problem following the syntax of this language as it is fairly standard.</p>

<p>Examples of valid triples are:</p>

<p><span  class="math">\[\{x=0\}x:=x+1\{x=1\}\]</span></p>

<p>This triple is valid because if before the execution it holds that <span  class="math">\(x=0\)</span>, then after the execution of the assignment command the assertion <span  class="math">\(x=1\)</span> will hold as well. An important condition for the validity of a triple is the termination, but since the command is an assignment, it always terminates (except for when we have an undefined expression on the right hand side, like <span  class="math">\(x/0\)</span>, but for simplicity we will just assume that the program we will write will never try to evaluate an undefined expression).</p>

<p><span  class="math">\[\{ x=A \land y=B\}z:=x; x:=y; y:=z\{x=B \land y=A\}\]</span></p>

<p>This is a variable swap, notice that this triple is completely <strong>parametric</strong>, as it uses two constants (<span  class="math">\(A\)</span> and <span  class="math">\(B\)</span>) that stand for arbitrary values. This is a very powerful thing you can do in Hoare logic, as this triple is valid for all values of <span  class="math">\(x\)</span> and <span  class="math">\(y\)</span>.</p>

<p>But we can have even more complicated triples, such as</p>

<p><span  class="math">\[\{s=\sum_{k=0}^i k^2\}i:=i+1;s:=s+i*i\{s=\sum_{k=0}^i k^2\}\]</span></p>

<p>or</p>

<p><span  class="math">\[\{n \geq 1\}\\\text{while}(n \neq 1) \text{do if} (n \text{ mod } 2 = 0) \text{ then } n:=n/2\text{ else } n:= 3n+1 \text{ fi endw}\\\{n=1\}\]</span></p>

<p>you may have recognized this triple, as it is valid iff the Collatz conjecture is true. Also this is an example where proving just the termination of the command is very important and not trivial at all (in fact, proving the termination is sufficient for proving the entire triple).</p>

<h2 id="what-is-an-inference-rule">What is an inference rule?</h2>

<p>I'm sure if you are reading this, that you will be familiar with the concept of inference, but just to make sure we are all on the same page and to make clear the notation used, it's best to discuss this important concept.</p>

<p>An inference rule has the form</p>

<p><span  class="math">\[\frac{\phi_1 \quad \phi_2 \quad \phi_3 \quad \dots \quad \phi_n}{\phi}\]</span></p>

<p>where <span  class="math">\(\phi_1 \dots \phi_n\)</span> are the premises and <span  class="math">\(\phi\)</span> is the conclusion. This can be read in two ways:</p>

<ol>
<li>if <span  class="math">\(\phi_1 \dots \phi_n\)</span> are all valid formulas, then we can infer (or derive) the formula <span  class="math">\(\phi\)</span></li>
<li>to prove <span  class="math">\(\phi\)</span> it is sufficient to prove that <span  class="math">\(\phi_1 \dots \phi_n\)</span> are all valid formulas.</li>
</ol>

<p>For our purpose, the second interpretetion is what fits the best, so keep in mind this intuition behind inference rules.</p>

<p>An <strong>axiom</strong> is just an inference rule with no premises, so that if <span  class="math">\(\psi\)</span> is an axiom we will write</p>

<p><span  class="math">\[\frac{}{\psi}\]</span></p>

<p>Examples of inference rules in classical propositional calculus are</p>

<p><span  class="math">\[\frac{A \land B}{A}\quad (\land \text{ elimination})\]</span></p>

<p><span  class="math">\[\frac{A \to B \quad \neg B }{\neg A}\quad \text{(Modus Tollens)}\]</span></p>

<p>For example, the last one in our interpretation is read &quot;to prove that <span  class="math">\(\neg A\)</span> is valid it is sufficient to prove that <span  class="math">\(A \to B\)</span> and <span  class="math">\(\neg B\)</span> are both valid&quot;.</p>

<h2 id="a-proof-system-for-hoare-triples">A proof system for Hoare triples</h2>

<h3 id="axioms">Axioms</h3>

<p>Now let's discuss about how to formally prove that a triple is valid. Let's start with some axioms: these are basic triples that are always valid.</p>

<p>The first axiom is the empty command axiom (or skip axiom):</p>

<p><span  class="math">\[\frac{}{\{P\}\text{skip}\{P\}}\quad (\text{SKIP-AX})\]</span></p>

<p>where <span  class="math">\(P\)</span> is an arbitrary assertion and <span  class="math">\(\text{skip}\)</span> is the empty command. The intuition behind this axiom is that if a certain condition holds before the skip statement, then it will also hold after the execution, because skip does not modify the state and always terminates.</p>

<p>The second axiom is the assignment axiom:</p>

<p><span  class="math">\[\frac{}{\{P[x \mapsto E]\}x:=E\{P\}}\quad (\text{ASSIGNMENT-AX})\]</span></p>

<p>where <span  class="math">\(P[x \mapsto E]\)</span> means the assertion <span  class="math">\(P\)</span> with all the occurrences of <span  class="math">\(x\)</span> replaced by <span  class="math">\(E\)</span>. The intuition behind this axiom is that if an assertion must hold true after the assignment statement, then it must hold also before the statement, but with the identifier substituted by the expression.</p>

<h3 id="basic-inference-rules">Basic inference rules</h3>

<p>Now, let's talk about some serious stuff: inference rules. The first one is pretty straight forward, and it is the pre-post rule:</p>

<p><span  class="math">\[\frac{P\to P' \quad \{P'\}C\{Q'\} \quad Q' \to Q}{\{P\}C\{Q\}}\quad \text{(PRE-POST)}\]</span></p>

<p>The intuition behind this rule is that we can strengthen the precondition and we can weaken the postcondition at our favor.</p>

<p>This rule is really important because with this and the two axioms we can derive the second and the third inference rules:</p>

<p><span  class="math">\[\frac{P \to Q}{\{P\}\text{skip}\{Q\}}\quad (\text{SKIP})\]</span></p>

<p><span  class="math">\[\frac{P \to Q[x \mapsto E]}{\{P\}x:=E\{Q\}}\quad (\text{ASSIGNMENT})\]</span></p>

<p>The next rule is the composition rule (or sequence rule):</p>

<p><span  class="math">\[\frac{\{P\}C_1\{R\} \quad \{R\}C_2\{Q\}}{\{P\}C_1;C_2\{Q\}}\quad (\text{COMPOSITION})\]</span></p>

<p>The intuition behind this rule is that if it can be found an intermediate assertion (in this case <span  class="math">\(R\)</span>) so that the two single triples are valid, then the whole triple is also valid.</p>

<h3 id="contditional-and-while-rules">Contditional and while rules</h3>

<p>Now let's see the most difficult rules: the if and the while rules. Let's start with the conditional one:</p>

<p><span  class="math">\[\frac{\{P \land E\}C_1\{Q\} \quad \{P \land \neg E\}C_2\{Q\}}{\{P\}\text{if } E \text{ then } C_1 \text{ else } C_2\{Q\}}\quad (\text{IF})\]</span></p>

<p>The intuition behind this rule is that we have to prove the triple both in the case that the guard is satisfied and in the case that it is not satisfied, so that in the general case the triple holds. This rule remembers me the proof by cases in propositional calculus, that is:</p>

<p><span  class="math">\[\frac{P \to Q \quad \neg P \to Q}{Q}\quad \text{Proof by cases}\]</span></p>

<p>but I'm digressing.</p>

<p>Let's talk about the while rule. I'm ging to present this monstruosity so that we can then break it down piece by piece:</p>

<p><span  class="math">\[\frac{\begin{gathered} P \to inv \quad inv \to Q \quad inv \to t \geq 0 \\\{inv \land E\}C\{inv\} \quad \{inv \land E \land t=V\}C\{ t \lt V \} \end{gathered}}{\{P\}\text{while }E \text{ do } C \text{ endw}\{Q\}}\quad \text{(WHILE)}\]</span></p>

<p>Ok, so, take a deep breath, because this will be kind of a long one. The semantics of the while command is just a composition of the same command (that is the body of the while). So the semantics of the while can be expanded as follows:</p>

<p><span  class="math">\[\overbrace{C;C;C;C;C \dots C}^{n \text{ times}}\]</span></p>

<p>where <span  class="math">\(n\)</span> is the number of times the body of the while will be executed. Notice that the guard may never become false, in that case the sequence of commands is infinite. To prove that this command terminates and the sequence of commands is finite, we assign a <strong>natural</strong> number (which is identified by the expression <span  class="math">\(t\)</span>) to each cycle, so that we create a sequence. Now to prove that this sequence terminates we just have to prove that this sequence is <strong>strictly decreasing</strong> (we use a theorem that states that every strictly decreasing sequence of natural numbers is finite).</p>

<p>To do this we can use a thing called <strong>loop invariant</strong> (often called only <span  class="math">\(inv\)</span>), that is an assertion that is true at the beginning of every iteration. With this we can prove the termination and also we can be sure that the precondition and postcondition are satisfied.</p>

<p>Now, with everithig settled in, let's discuss in some detail the 5 premises of the while rule:</p>

<ol>
<li><span  class="math">\(\{inv \land E\}C\{inv\}\)</span>: this is called the <strong>invariance</strong> premise, as it makes sure that the <span  class="math">\(inv\)</span> assertion is true at the beginning of each iteration.</li>
<li><span  class="math">\(P \to inv\)</span>: this is called the <strong>pre</strong> premise, as is simply make sure that the precondition is stronger than the invariant, so that the first time we enter the loop, the invariant holds.</li>
<li><span  class="math">\( inv \to Q\)</span>: this is called <strong>post</strong> premis, and as the name sugest make sure that the if the invariant is true, then also the postcondition is true. This is done so that at the end of the execution we can make sure that the postcondition holds true, since we know that the invariant holds true.</li>
<li><span  class="math">\(\{inv \land E \land t=V\}C\{ t \lt V \}\)</span>: this is called <strong>progress</strong> premise, as it make sure that each term of the sequence is strictly decreasing.</li>
<li><span  class="math">\(inv \to t\geq 0\)</span>: last but not least the <strong>termination</strong> premise, that make sure that our sequence identified by the expression <span  class="math">\(t\)</span> has a lower bound, in this case 0, so that we can make sure it is finite.</li>
</ol>

<p>Whoa! That was quite a jurney! But now let's stop talking about theory and let's jump into the code!</p>

<h1 id="the-automatic-theorem-prover">The automatic theorem prover</h1>

<h2 id="premises">Premises</h2>

<p>For this project I choose python as the main language because I was not aiming at a full-fledged and efficient prover, but more at a proof-of-concept or prototype program, in which python is really great.
In particular I used <a href="https://github.com/Z3Prover/z3">z3 theorem prover</a> for proving the implications, and <a href="https://github.com/Z3Prover/z3">lark</a> for parsing the input triple. The whole project is on <a href="https://github.com/gio54321/hoare-logic-prover">github</a>, pull requests are welcome!</p>

<h2 id="the-parser">The parser</h2>

<p>Using lark, parsing was surprisingly easy. I just defined the grammar into a big string and lark taked care of everything. The grammar can be seen in the <a href="https://github.com/gio54321/hoare-logic-prover/blob/master/src/lpp_parser.py">source code for the parser</a>. An example triple that can be accepted by the parser is:</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">[x, A]
{x==A}
x := x-3;
if (x &gt;= 0) then
    x := x + 5
else
    x := -x + 5
fi
{x&gt;A}</code></pre></div>
<p>In the first line we declare all the identifiers that we are going to use in the triple. Then we state the precondition, the command and the postcondition. The triple procesed by the parser produces a <strong>parse tree</strong>, which is perfect because we will do a lot of induction on the structure of the program.</p>

<h2 id="the-prover">The prover</h2>

<p>The basic building block for the theorem prover is a function that takes in input a z3 formula and tries to prove the validity of if. This is implemented as follows.</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">prove_formula</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">what_to_prove</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">Solver</span><span class="p">()</span>
    <span class="n">s</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">Not</span><span class="p">(</span><span class="n">what_to_prove</span><span class="p">))</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">check</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&#34;unsat&#34;</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&#34;proved&#34;</span><span class="p">,</span> <span class="n">what_to_prove</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&#34;could not prove&#34;</span><span class="p">,</span> <span class="n">what_to_prove</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">False</span></code></pre></div>
<p>The z3's check function can only give you 2 results: <code>sat</code>, which means that the formula is satisfiable, and <code>unsat</code>, which means the formula is unsatisfiable. So there is no result for valid, but we can use a well known fact in logic: a formula <span  class="math">\(\phi\)</span> is valis iff <span  class="math">\(\neg \phi\)</span> is unsatisfiable. So we negate the formula and if it is unsatisfiable, then the formula is considered proved.</p>

<p>Now let's start implementing the main protagonist of this jurney: the <code>prove_triple()</code> function, that takes in input a precondition as a z3 formula, a command as a parse tree and a postcondition as a z3 formula and returns True if the triple is valid, False otherwise. The first inference rule we will implement is the simplest one: the <strong>skip</strong> rule.</p>

<p><span  class="math">\[\frac{P \to Q}{\{P\}\text{skip}\{Q\}}\quad (\text{SKIP})\]</span></p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">prove_triple</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">precond</span><span class="p">,</span> <span class="n">command</span><span class="p">,</span> <span class="n">postcond</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">command</span><span class="o">.</span><span class="n">data</span> <span class="o">==</span> <span class="s2">&#34;skip&#34;</span><span class="p">:</span>
        <span class="n">formula_to_prove</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">Implies</span><span class="p">(</span><span class="n">precond</span><span class="p">,</span> <span class="n">postcond</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&#34;found skip statement, trying to prove&#34;</span><span class="p">,</span> <span class="n">formula_to_prove</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prove_formula</span><span class="p">(</span><span class="n">formula_to_prove</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span></code></pre></div>
<p>Here we state that for proving a skip triple it is sufficient to prove that the precondition implies the postcondition.</p>

<p>Now let's implement the <strong>assignment</strong> inference rule.</p>

<p><span  class="math">\[\frac{P \to Q[x \mapsto E]}{\{P\}x:=E\{Q\}}\quad (\text{ASSIGNMENT})\]</span></p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">elif</span> <span class="n">command</span><span class="o">.</span><span class="n">data</span> <span class="o">==</span> <span class="s2">&#34;assignment&#34;</span><span class="p">:</span>
    <span class="n">ide</span><span class="p">,</span> <span class="n">exp</span> <span class="o">=</span> <span class="n">command</span><span class="o">.</span><span class="n">children</span>
    <span class="n">formula_to_prove</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">Implies</span><span class="p">(</span>
        <span class="n">precond</span><span class="p">,</span>
        <span class="n">z3</span><span class="o">.</span><span class="n">substitute</span><span class="p">(</span><span class="n">postcond</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="p">[</span><span class="n">ide</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr_to_z3_formula</span><span class="p">(</span><span class="n">exp</span><span class="p">)))</span>
    <span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&#34;found assignment statement, trying to prove&#34;</span><span class="p">,</span> <span class="n">formula_to_prove</span><span class="p">)</span>
    <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prove_formula</span><span class="p">(</span><span class="n">formula_to_prove</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">res</span></code></pre></div>
<p>Now let's go on and implement the <strong>conditional</strong> inference rule. This is when <code>prove_triple</code> becomes <strong>inductive</strong>, as it calls itself on a subtree of the parse tree.</p>

<p><span  class="math">\[\frac{\{P \land E\}C_1\{Q\} \quad \{P \land \neg E\}C_2\{Q\}}{\{P\}\text{if } E \text{ then } C_1 \text{ else } C_2\{Q\}}\quad (\text{IF})\]</span></p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">elif</span> <span class="n">command</span><span class="o">.</span><span class="n">data</span> <span class="o">==</span> <span class="s2">&#34;if&#34;</span><span class="p">:</span>
    <span class="n">guard</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">command</span><span class="o">.</span><span class="n">children</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&#34;found if statement, trying to prove the first alternative&#34;</span><span class="p">)</span>
    <span class="n">res_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prove_triple</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">And</span><span class="p">(</span><span class="n">precond</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr_to_z3_formula</span><span class="p">(</span><span class="n">guard</span><span class="p">)),</span> <span class="n">s1</span><span class="p">,</span> <span class="n">postcond</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">res_1</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&#34;now trying to prove the second alternative&#34;</span><span class="p">)</span>
        <span class="n">res_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prove_triple</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">And</span><span class="p">(</span><span class="n">precond</span><span class="p">,</span> <span class="n">z3</span><span class="o">.</span><span class="n">Not</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expr_to_z3_formula</span><span class="p">(</span><span class="n">guard</span><span class="p">))),</span> <span class="n">s2</span><span class="p">,</span> <span class="n">postcond</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res_2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span></code></pre></div>
<p>There is nothing magical in the code yet: these three cases are the direct translation of the inference rule.</p>

<p>Now let's talk about <strong>composition</strong>. From the inference rule we know we have to search for an intermediate assertion, so that both intermediate triples are valid.</p>

<p><span  class="math">\[\frac{\{P\}C_1\{R\} \quad \{R\}C_2\{Q\}}{\{P\}C_1;C_2\{Q\}}\quad (\text{COMPOSITION})\]</span></p>

<p>There is no rule on how to find it, but we can use some heuristics to find it. Basically we try to find an assertion <span  class="math">\(R\)</span> so that <span  class="math">\(\{R\}C_2\{Q\}\)</span> is an <strong>axiom</strong> (so is valid in our proof system) and then we delegate the validity of the whole triple to the validity of <span  class="math">\(\{P\}C_1\{R\}\)</span>. To do this we need a new function called <em>find_axiom</em> that takes in input a command as a parse tree and a postondition as a z3 formula and tries to find a precondition so that the triple is an axiom. Remember that there are only two axioms in our system, so we can implement only them.</p>

<p><span  class="math">\[\frac{}{\{P\}\text{skip}\{P\}}\quad (\text{SKIP-AX})\]</span></p>

<p><span  class="math">\[\frac{}{\{P[x \mapsto E]\}x:=E\{P\}}\quad (\text{ASSIGNMENT-AX})\]</span></p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">find_axiom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">command</span><span class="p">,</span> <span class="n">postcond</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">command</span><span class="o">.</span><span class="n">data</span> <span class="o">==</span> <span class="s2">&#34;skip&#34;</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&#34;found axiom for skip statement:&#34;</span><span class="p">,</span> <span class="n">postcond</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">True</span><span class="p">,</span> <span class="n">postcond</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">command</span><span class="o">.</span><span class="n">data</span> <span class="o">==</span> <span class="s2">&#34;assignment&#34;</span><span class="p">:</span>
        <span class="n">ide</span><span class="p">,</span> <span class="n">exp</span> <span class="o">=</span> <span class="n">command</span><span class="o">.</span><span class="n">children</span>
        <span class="n">axiom</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">substitute</span><span class="p">(</span><span class="n">postcond</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="p">[</span><span class="n">ide</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr_to_z3_formula</span><span class="p">(</span><span class="n">exp</span><span class="p">)))</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&#34;found axiom for assignment statement:&#34;</span><span class="p">,</span> <span class="n">axiom</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">True</span><span class="p">,</span> <span class="n">axiom</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&#34;could not find axiom&#34;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">False</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span></code></pre></div>

<p>Now we are all set for implementing the composition rule.</p>

<p><span  class="math">\[\frac{\{P\}C_1\{R\} \quad \{R\}C_2\{Q\}}{\{P\}C_1;C_2\{Q\}}\quad (\text{COMPOSITION})\]</span></p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">elif</span> <span class="n">command</span><span class="o">.</span><span class="n">data</span> <span class="o">==</span> <span class="s2">&#34;composition&#34;</span><span class="p">:</span>
    <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span> <span class="o">=</span> <span class="n">command</span><span class="o">.</span><span class="n">children</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&#34;found composition, trying to find axiom for the right side&#34;</span><span class="p">)</span>
    <span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">axiom</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_axiom</span><span class="p">(</span><span class="n">c2</span><span class="p">,</span> <span class="n">postcond</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">res</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">prove_triple</span><span class="p">(</span><span class="n">precond</span><span class="p">,</span> <span class="n">c1</span><span class="p">,</span> <span class="n">axiom</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span></code></pre></div>

<p>With theese simple inference rules implemented, we can try our prover on a variable swap. So the input triple looks like this:</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">[x, y, z, A, B]
{x==A and y==B}
z := x;
x := y;
y := z
{x==B and y==A}</code></pre></div>
<p>The output of our prover is:</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">What to prove: [x, y, z, A, B]
{x==A and y==B}
z := x;
x := y;
y := z
{x==B and y==A}

found composition, trying to find axiom for the right side
found axiom for assignment statement: And(x == B, z == A)
found composition, trying to find axiom for the right side
found axiom for assignment statement: And(y == B, z == A)
found assignment statement, trying to prove Implies(And(x == A, y == B), And(y == B, x == A))
proved Implies(And(x == A, y == B), And(y == B, x == A))

The triple is valid</code></pre></div>
<p>Yay! So the verdict is that this triple is valid! That means that so far our little prover works! The great thing is that you can see the process of the program by looking at the output, and we can see that the steps made by our little program are  exactly what we expected.</p>

<p>Now we just have to implement the scary one: the <strong>while</strong> inference rule. Luckly we got the hang of it, and now the code is pretty much a direct application of the inference rule.</p>

<p><span  class="math">\[\frac{\begin{gathered} P \to inv \quad inv \to Q \quad inv \to t \geq 0 \\\{inv \land E\}C\{inv\} \quad \{inv \land E \land t=V\}C\{ t \lt V \} \end{gathered}}{\{P\}\text{while }E \text{ do } C \text{ endw}\{Q\}}\quad \text{(WHILE)}\]</span></p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">elif</span> <span class="n">command</span><span class="o">.</span><span class="n">data</span> <span class="o">==</span> <span class="s2">&#34;while&#34;</span><span class="p">:</span>
    <span class="n">e</span><span class="p">,</span> <span class="n">t_expr</span><span class="p">,</span> <span class="n">inv</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">command</span><span class="o">.</span><span class="n">children</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&#34;found while statement, trying to prove:&#34;</span><span class="p">)</span>
    <span class="n">invariant</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr_to_z3_formula</span><span class="p">(</span><span class="n">inv</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr_to_z3_formula</span><span class="p">(</span><span class="n">t_expr</span><span class="p">)</span>
    <span class="n">guard</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr_to_z3_formula</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
    <span class="n">pre</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">Implies</span><span class="p">(</span><span class="n">precond</span><span class="p">,</span> <span class="n">invariant</span><span class="p">)</span>
    <span class="n">post</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">Implies</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">And</span><span class="p">(</span><span class="n">precond</span><span class="p">,</span> <span class="n">z3</span><span class="o">.</span><span class="n">Not</span><span class="p">(</span><span class="n">guard</span><span class="p">)),</span> <span class="n">postcond</span><span class="p">)</span>
    <span class="n">term</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">Implies</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">And</span><span class="p">(</span><span class="n">invariant</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="p">[</span><span class="s2">&#34;t&#34;</span><span class="p">]</span> <span class="o">==</span> <span class="n">t</span><span class="p">),</span> <span class="n">t</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&#34;1) [pre]&#34;</span><span class="p">,</span> <span class="n">pre</span><span class="p">)</span>
    <span class="n">res_pre</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prove_formula</span><span class="p">(</span><span class="n">pre</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">res_pre</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&#34;2) [post]&#34;</span><span class="p">,</span> <span class="n">post</span><span class="p">)</span>
        <span class="n">res_post</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prove_formula</span><span class="p">(</span><span class="n">post</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">res_post</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s2">&#34;3) [term]&#34;</span><span class="p">,</span> <span class="n">term</span><span class="p">)</span>
            <span class="n">res_term</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prove_formula</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">res_term</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s2">&#34;4) [invariance]&#34;</span><span class="p">,</span> <span class="n">term</span><span class="p">)</span>
                <span class="n">res_inv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prove_triple</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">And</span><span class="p">(</span><span class="n">invariant</span><span class="p">,</span> <span class="n">guard</span><span class="p">),</span> <span class="n">c</span><span class="p">,</span> <span class="n">invariant</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">res_inv</span><span class="p">:</span>
                    <span class="k">print</span><span class="p">(</span><span class="s2">&#34;5) [progress]&#34;</span><span class="p">,</span> <span class="n">term</span><span class="p">)</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">Int</span><span class="p">(</span><span class="s2">&#34;V&#34;</span><span class="p">)</span>
                    <span class="n">res</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">prove_triple</span><span class="p">(</span>
                        <span class="n">z3</span><span class="o">.</span><span class="n">And</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">And</span><span class="p">(</span><span class="n">invariant</span><span class="p">,</span> <span class="n">guard</span><span class="p">),</span> <span class="n">t</span><span class="o">==</span><span class="n">v</span><span class="p">),</span>
                        <span class="n">c</span><span class="p">,</span>
                        <span class="n">t</span><span class="o">&lt;</span><span class="n">v</span>
                    <span class="p">)</span>
                    <span class="k">return</span> <span class="n">res</span>
    <span class="k">return</span> <span class="bp">False</span></code></pre></div>
<p>So now we can finally prove some simple while triples! I have added some syntax to the while command to code the loop invariant and the expression for <span  class="math">\(t\)</span>. Here's an example triple that calculates <span  class="math">\(5 \cdot 10\)</span> in a very stupid way:</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">[i, s, t, r]
{i==0 and r==0}
while (i&lt;10) where t is (10-i); inv is (r==5*i and 10-i&gt;=0) do
    i := i+1;
    r := r+5
endw
{r==5*10}</code></pre></div>
<p>This time the output is a bit more cluttered:</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">What to prove: [i, s, t, r]
{i==0 and r==0}
while (i&lt;10) where t is (10-i); inv is (r==5*i and 10-i&gt;=0) do
    i := i+1;
    r := r+5
endw
{r==5*10}

found while statement, trying to prove:
1) [pre] Implies(And(0 == i, 0 == r), And(r == 5*i, 0 &lt;= 10 - i))
proved Implies(And(0 == i, 0 == r), And(r == 5*i, 0 &lt;= 10 - i))
2) [post] Implies(And(And(0 == i, 0 == r), Not(10 &gt; i)), r == 5*10)
proved Implies(And(And(0 == i, 0 == r), Not(10 &gt; i)), r == 5*10)
3) [term] Implies(And(And(r == 5*i, 0 &lt;= 10 - i), t == 10 - i),
        10 - i &gt;= 0)
proved Implies(And(And(r == 5*i, 0 &lt;= 10 - i), t == 10 - i),
        10 - i &gt;= 0)
4) [invariance] Implies(And(And(r == 5*i, 0 &lt;= 10 - i), t == 10 - i),
        10 - i &gt;= 0)
found composition, trying to find axiom for the right side
found axiom for assignment statement: And(r + 5 == 5*i, 0 &lt;= 10 - i)
found assignment statement, trying to prove Implies(And(And(r == 5*i, 0 &lt;= 10 - i), 10 &gt; i),
        And(r + 5 == 5*(i + 1), 0 &lt;= 10 - (i + 1)))
proved Implies(And(And(r == 5*i, 0 &lt;= 10 - i), 10 &gt; i),
        And(r + 5 == 5*(i + 1), 0 &lt;= 10 - (i + 1)))
5) [progress] Implies(And(And(r == 5*i, 0 &lt;= 10 - i), t == 10 - i),
        10 - i &gt;= 0)
found composition, trying to find axiom for the right side
found axiom for assignment statement: 10 - i &lt; V
found assignment statement, trying to prove Implies(And(And(And(r == 5*i, 0 &lt;= 10 - i), 10 &gt; i),
            10 - i == V),
        10 - (i + 1) &lt; V)
proved Implies(And(And(And(r == 5*i, 0 &lt;= 10 - i), 10 &gt; i),
            10 - i == V),
        10 - (i + 1) &lt; V)

The triple is valid</code></pre></div>
<p>Great! We can see exactly that all 5 while premises have been proved, so it is fair to say that this loop has been proven formally that it <strong>terminates</strong> and r will contain the result of <span  class="math">\(5 \cdot 10\)</span>.</p>

<p>To experiment with this simple system (and maybe contribute to it) you can clone <a href="https://github.com/gio54321/hoare-logic-prover">the repository</a>, and you can run an example proof (for example the variable swap one) by:</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ python src/lpp_prover.py examples/var_swap.lpp</code></pre></div>
<p>In the <a href="https://github.com/gio54321/hoare-logic-prover/tree/master/examples">examples folder</a> on github there are a bunch of triples that should give you the feeling of the capability of this system.</p>

<h1 id="conclusions">Conclusions</h1>

<p>This was a very interesting project for me, because it game me the possibility to apply all this theoretical stuff I learned at university. This is not, and does not aim to be a professional formal prover, it is just a little program written by a bored cs student.</p>

                </section>
            </article>

            
                <a class="twitter" href="https://twitter.com/intent/tweet?text=https%3a%2f%2fgio54321.github.io%2fposts%2fhoare-prover%2f - A%20simple%20Hoare%20triple%20prover by @g_dellimmagine"><span class="icon-twitter"> tweet</span></a>

<a class="facebook" href="#" onclick="
    window.open(
      'https://www.facebook.com/sharer/sharer.php?u='+encodeURIComponent(location.href),
      'facebook-share-dialog',
      'width=626,height=436');
    return false;"><span class="icon-facebook-rect"> Share</span>
</a>

            

            

            

            <footer id="footer">
    
        <div id="social">

	
	
    <a class="symbol" href="https://www.github.com/gio54321">
        <i class="fa fa-github-square"></i>
    </a>
    
    <a class="symbol" href="https://www.twitter.com/g_dellimmagine">
        <i class="fa fa-twitter-square"></i>
    </a>
    


</div>

    
    <p class="small">
    
       © Copyright 2021 <i class="fa fa-heart" aria-hidden="true"></i> Giorgio Dell&#39;Immagine
    
    </p>
    <p class="small">
        Powered by <a href="http://www.gohugo.io/">Hugo</a>
    </p>
</footer>

        </section>

        <script>
  let c = document.querySelectorAll('code');
  for (let i=0; i<c.length; i++){
    if (c[i].classList.length == 0){
      console.log(c[i]);
      c[i].classList.add("language-none");
    }
  }
</script>

<script src="https://gio54321.github.io/js/jquery-3.3.1.min.js"></script>
<script src="https://gio54321.github.io/js/main.js"></script>
<script src="https://gio54321.github.io/js/prism.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">

<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>

<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>







    </body>
</html>
